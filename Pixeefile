#!/usr/bin/env python3
"""
dd_cleanup.py

List and delete DefectDojo objects via API v2.

Usage examples:
  # Dry-run: show users that would be deleted
  python dd_cleanup.py --api-key YOURTOKEN --base-url https://demo.defectdojo.org --resource users

  # Actually delete all findings (no confirmation per item)
  python dd_cleanup.py --api-key YOURTOKEN --base-url https://demo.defectdojo.org --resource findings --yes

  # Delete only items matching a query (e.g. ?email=joe@example.com)
  python dd_cleanup.py --api-key YOURTOKEN --resource users --filter "email=joe@example.com" --yes
"""

import argparse
import requests
import sys
import time
from urllib.parse import urljoin

# --- Configuration / defaults ---
DEFAULT_BASE = "https://demo.defectdojo.org"  # change if needed
API_PREFIX = "/api/v2/"

# Map friendly resource names to API paths (v2)
VALID_RESOURCES = {
    "users": "users/",
    "products": "products/",
    "engagements": "engagements/",
    "tests": "tests/",
    "findings": "findings/",
}

# --- Helpers ---
def make_headers(api_key: str):
    if not api_key:
        raise ValueError("API key required. Provide via --api-key or set environment variable.")
    return {
        "Authorization": f"Token {api_key}",
        "Accept": "application/json",
    }

def paged_get(session: requests.Session, url: str, params=None):
    """Yield results from a paginated DRF response (expects 'results' & 'next' keys)."""
    params = params or {}
    while url:
        resp = session.get(url, params=params, timeout=60)
        if resp.status_code != 200:
            raise RuntimeError(f"GET {url} failed: {resp.status_code} {resp.text}")
        j = resp.json()
        # Some endpoints may return list directly; handle both
        if isinstance(j, dict) and "results" in j:
            for item in j["results"]:
                yield item
            url = j.get("next")
            params = None  # only send params on first page
        elif isinstance(j, list):
            for item in j:
                yield item
            # no pagination info -> stop
            url = None
        else:
            raise RuntimeError(f"Unexpected response shape from {url}: {j}")

def delete_item(session: requests.Session, base_api_url: str, api_path: str, item_id: int):
    """Send DELETE to /api/v2/<api_path>/<id>/ and return (status_code, text)."""
    target = urljoin(base_api_url, f"{api_path}{item_id}/")
    resp = session.delete(target, timeout=120)
    return resp.status_code, resp.text

def build_list_url(base_url: str, api_path: str):
    return urljoin(base_url, API_PREFIX + api_path)

# --- CLI and main logic ---
def main():
    p = argparse.ArgumentParser(description="DefectDojo bulk delete helper (dry-run default).")
    p.add_argument("--api-key", "-k", required=True, help="DefectDojo API token (user token).")
    p.add_argument("--base-url", "-b", default=DEFAULT_BASE, help=f"Base URL of DefectDojo (default: {DEFAULT_BASE})")
    p.add_argument("--resource", "-r", required=True, choices=VALID_RESOURCES.keys(),
                   help="Resource to target (users, products, engagements, tests, findings).")
    p.add_argument("--filter", "-f", help="Optional query string (e.g. 'email=joe@example.com' or 'product=12').")
    p.add_argument("--yes", "-y", action="store_true", help="Actually perform deletions. Without it, script runs in dry-run mode.")
    p.add_argument("--sleep", type=float, default=0.0, help="Seconds to sleep between deletes (useful to throttle).")
    args = p.parse_args()

    base = args.base_url.rstrip("/") + "/"
    api_path = VALID_RESOURCES[args.resource]

    headers = make_headers(args.api_key)
    session = requests.Session()
    session.headers.update(headers)

    list_url = build_list_url(base, api_path)
    params = {}
    if args.filter:
        # parse simple query string into params (supports multiple & separated)
        for kv in args.filter.split("&"):
            if "=" in kv:
                k, v = kv.split("=", 1)
                params[k] = v
            else:
                print(f"Ignoring malformed filter fragment: {kv}", file=sys.stderr)

    print(f"Listing {args.resource} from {list_url} with params={params or None} ...")
    candidates = []
    try:
        for item in paged_get(session, list_url, params=params):
            # present common keys for each resource
            rid = item.get("id") or item.get("pk") or item.get("user") or "UNKNOWN"
            name = item.get("username") or item.get("name") or item.get("title") or item.get("title_string") or item.get("title") or item.get("title_text") or item.get("title", "")
            # fallback: try to form a useful display string
            display = None
            if args.resource == "users":
                display = f"{rid} - {item.get('username')} <{item.get('email')}> (is_active={item.get('is_active')})"
            elif args.resource == "products":
                display = f"{rid} - {item.get('name')} (type={item.get('prod_type')})"
            elif args.resource == "engagements":
                display = f"{rid} - {item.get('name')} (product={item.get('product')})"
            elif args.resource == "tests":
                display = f"{rid} - {item.get('test_type')} (engagement={item.get('engagement')})"
            elif args.resource == "findings":
                display = f"{rid} - {item.get('title')} (severity={item.get('severity')})"
            else:
                display = f"{rid} - {name}"
            candidates.append((rid, display))
    except Exception as e:
        print("Failed to list objects:", str(e), file=sys.stderr)
        sys.exit(2)

    if not candidates:
        print("No matching items found.")
        sys.exit(0)

    print("\nFound items:")
    for rid, display in candidates:
        print(" ", display)

    if not args.yes:
        print("\nDRY RUN (no deletions performed). Re-run with --yes to actually delete.")
        sys.exit(0)

    print("\nProceeding to delete items...")
    for rid, display in candidates:
        print(f"Deleting {display} ... ", end="", flush=True)
        status, text = delete_item(session, base, api_path, rid)
        if status in (200, 202, 204):
            print(f"OK ({status})")
        else:
            print(f"FAILED ({status}) - {text}")
        if args.sleep:
            time.sleep(args.sleep)

    print("Done.")

if __name__ == "__main__":
    main()