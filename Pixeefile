import pandas as pd
import requests
import base64
import json
from flask import Flask, render_template, request
import traceback  # For error logging

app = Flask(__name__)

# Hardcoded credentials (replace with your actual values)
BITBUCKET_API_BASE = "https://bitbucket.crm.com/rest/api/latest"
USERNAME = "your-username"  # Replace with your Bitbucket Server username
PASSWORD = "your-password"  # Replace with your Bitbucket Server password
EXCEL_FILE = "repos.xlsx"
FILES_LIMIT = 100

# Encode credentials for Basic Authentication
credentials = f"{USERNAME}:{PASSWORD}"
auth_header = f"Basic {base64.b64encode(credentials.encode()).decode()}"

headers = {
    "Authorization": auth_header,
    "Accept": "application/json"
}

def get_latest_tag(project_key, repo_slug):
    """Get the latest tag ID from the repository's tags endpoint."""
    try:
        url = f"{BITBUCKET_API_BASE}/projects/{project_key}/repos/{repo_slug}/tags?orderBy=NAME_DESC&limit=1"
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            try:
                data = response.json()
                if not isinstance(data, dict):
                    print(f"Non-dict tags response for {project_key}/{repo_slug}: {response.text}")  # Console log
                    return None
                values = data.get("values", [])
                if not values:
                    return None
                latest_tag = values[0].get("id")  # e.g., "refs/tags/v1.4.4"
                return latest_tag
            except json.JSONDecodeError:
                print(f"Non-JSON tags response for {project_key}/{repo_slug} (Status {response.status_code}): {response.text}")  # Console log
                return None
        else:
            print(f"Error fetching tags for {project_key}/{repo_slug} (Status {response.status_code}): {response.text}")  # Console log
            return None
    except requests.exceptions.RequestException as e:
        print(f"Request exception fetching tags for {project_key}/{repo_slug}: {e}")  # Console log
        return None

def get_file_content(project_key, repo_slug, file_path, ref):
    """Get raw content of a specific file at the given ref (tag or branch)."""
    try:
        url = f"{BITBUCKET_API_BASE}/projects/{project_key}/repos/{repo_slug}/raw/{file_path}?at={ref}"
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            return response.text
        return None
    except requests.exceptions.RequestException:
        return None

def search_file_content(project_key, repo_slug, keyword, ref):
    """Search for keyword in file contents at the given ref."""
    try:
        url = f"{BITBUCKET_API_BASE}/projects/{project_key}/repos/{repo_slug}/files?limit={FILES_LIMIT}"
        if ref:
            url += f"&at={ref}"
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            try:
                data = response.json()
                if not isinstance(data, dict):
                    print(f"Non-dict files response for {project_key}/{repo_slug}: {response.text}")  # Console log
                    return []
                values = data.get("values", [])
                matches = []
                for file_path in values:
                    if not isinstance(file_path, str):
                        continue
                    content = get_file_content(project_key, repo_slug, file_path, ref or 'default')
                    if content and keyword.lower() in content.lower():
                        # Extract matching lines for preview
                        lines = [line for line in content.split('\n') if keyword.lower() in line.lower()]
                        matches.append({
                            "file_path": file_path,
                            "matching_lines": lines[:5]  # Limit to first 5 lines
                        })
                return matches
            except json.JSONDecodeError:
                print(f"Non-JSON files response for {project_key}/{repo_slug} (Status {response.status_code}): {response.text}")  # Console log
                return []
        else:
            print(f"Error fetching files for {project_key}/{repo_slug} (Status {response.status_code}): {response.text}")  # Console log
            return []
    except requests.exceptions.RequestException as e:
        print(f"Request exception fetching files for {project_key}/{repo_slug}: {e}")  # Console log
        return []

@app.route('/', methods=['GET', 'POST'])
def index():
    keyword = ""
    results = []
    if request.method == 'POST':
        keyword = request.form.get('keyword', '').strip()
        if keyword:
            try:
                # Load repos from Excel
                df = pd.read_excel(EXCEL_FILE)
                if 'PROJECT' in df.columns and 'REPO' in df.columns:
                    for _, row in df.iterrows():
                        project_key = row["PROJECT"]
                        repo_slug = row["REPO"]
                        if pd.isna(project_key) or pd.isna(repo_slug):
                            continue
                        latest_tag = get_latest_tag(project_key, repo_slug)
                        ref = latest_tag if latest_tag else None
                        matches = search_file_content(project_key, repo_slug, keyword, ref)
                        if matches:
                            results.append({
                                "project": project_key,
                                "repo": repo_slug,
                                "tag": latest_tag or "default branch",
                                "matches": matches
                            })
            except Exception as e:
                print(f"Error processing search for keyword '{keyword}': {str(e)}")  # Console log
                print(traceback.format_exc())  # Full traceback to console
                # No flash message; errors logged to console only
                return render_template('index.html', keyword=keyword, results=results, error=str(e))
    return render_template('index.html', keyword=keyword, results=results)

@app.errorhandler(500)
def internal_error(error):
    print(f"500 Internal Server Error: {str(error)}")  # Console log
    print(traceback.format_exc())  # Full traceback to console
    return render_template('error.html'), 500

if __name__ == '__main__':
    app.run(debug=True)