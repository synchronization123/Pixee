"""
Produce an updated sla.xlsx with a NOT_SET column containing counts of NOT_SET
states from Count.xlsx.

Assumptions & behavior:
- Count.xlsx should contain:
    - a column named exactly 'Filename' (case-insensitive) OR a column containing 'file'
      (will try to find best match).
    - a column named 'analysis.state' (case-insensitive) OR a column containing 'analysis' or 'state'.
    - optionally a project column (containing 'project' in its name). If not present, the script
      derives the project name from the Filename by removing trailing suffixes _JAR and _Js (case-insensitive),
      and trimming spaces.
- sla.xlsx must contain the sheet 'Daily_Monitoring_Apps'. Project names are taken from column A.
- Result is written to 'sla_with_not_set.xlsx' (does not overwrite original by default).
"""

import re
import sys
import pandas as pd
from pathlib import Path

# Input file names (change if needed)
COUNT_XLSX = Path("Count.xlsx")
SLA_XLSX = Path("sla.xlsx")
SLA_SHEET = "Daily_Monitoring_Apps"
OUTPUT_SLA = Path("sla_with_not_set.xlsx")

def find_column(df, candidates):
    """Find first column in df whose name matches any candidate substring (case-insensitive)."""
    cols_lower = {c.lower(): c for c in df.columns}
    for cand in candidates:
        for lower, orig in cols_lower.items():
            if cand.lower() in lower:
                return orig
    return None

def normalize_project_from_filename(fname):
    """Derive project name from filename by removing trailing _JAR or _Js (case-insensitive)
       and stripping whitespace and file extensions if present."""
    if pd.isna(fname):
        return ""
    s = str(fname).strip()
    # If filename includes path, take basename
    s = Path(s).stem  # removes extension like .zip/.jar/etc
    # Remove common suffixes _JAR or _Js (case-insensitive) possibly repeated, and trailing separators
    # Use regex to strip one or more occurrences at the end
    s = re.sub(r'(?i)(?:[_\-\.]?(?:jar|js))+$', '', s)  # remove -jar, _JAR, .js, etc
    s = s.strip("_-. ").strip()
    return s

def main():
    # validate files
    if not COUNT_XLSX.exists():
        print(f"ERROR: {COUNT_XLSX} not found.")
        sys.exit(1)
    if not SLA_XLSX.exists():
        print(f"ERROR: {SLA_XLSX} not found.")
        sys.exit(1)

    # Read Count.xlsx
    df_count = pd.read_excel(COUNT_XLSX, engine="openpyxl")
    # Try to detect filename column
    filename_col = find_column(df_count, ["filename", "file", "name"])
    if filename_col is None:
        raise ValueError("Could not find a Filename column in Count.xlsx (looking for 'filename'/'file'/'name').")

    # Try to detect analysis.state column
    analysis_col = find_column(df_count, ["analysis.state", "analysis", "state"])
    if analysis_col is None:
        raise ValueError("Could not find an analysis.state column in Count.xlsx (looking for 'analysis.state'/'analysis'/'state').")

    # Try to detect explicit project column; if absent we'll derive from filename
    project_col = find_column(df_count, ["project", "project name", "project_name"])
    if project_col:
        # use explicit column but normalize whitespace and strings
        df_count["__project_used"] = df_count[project_col].fillna("").astype(str).str.strip()
    else:
        # derive from Filename
        df_count["__project_used"] = df_count[filename_col].apply(normalize_project_from_filename)

    # Normalize analysis.state values and create boolean NOT_SET indicator
    df_count["__analysis_state_norm"] = df_count[analysis_col].astype(str).str.strip().str.upper()
    df_count["__is_NOT_SET"] = df_count["__analysis_state_norm"] == "NOT_SET"

    # Group counts of NOT_SET by project name
    counts = (
        df_count[df_count["__is_NOT_SET"]]
        .groupby("__project_used", dropna=False)
        .size()
        .rename("NOT_SET_count")
        .reset_index()
    )
    # Convert to dict for fast lookup
    counts_map = dict(zip(counts["__project_used"], counts["NOT_SET_count"]))

    # Read SLA sheet
    xl = pd.ExcelFile(SLA_XLSX, engine="openpyxl")
    if SLA_SHEET not in xl.sheet_names:
        raise ValueError(f"Sheet '{SLA_SHEET}' not found in {SLA_XLSX}. Available sheets: {xl.sheet_names}")
    df_sla = xl.parse(SLA_SHEET, header=0)

    # Project names are in column A (first column)
    first_col_name = df_sla.columns[0]
    # Normalize SLA project names for matching
    def normalize_sla_proj(val):
        if pd.isna(val):
            return ""
        return str(val).strip()

    df_sla["_SLA_proj_normalized"] = df_sla[first_col_name].apply(normalize_sla_proj)

    # Map counts to SLA rows; default 0 when not found
    def lookup_count(sla_proj):
        # exact match first
        if sla_proj in counts_map:
            return int(counts_map[sla_proj])
        # try case-insensitive match
        for k, v in counts_map.items():
            if k.lower() == sla_proj.lower():
                return int(v)
        # try removing suffixes from SLA proj name and match again
        short = normalize_project_from_filename(sla_proj)
        if short in counts_map:
            return int(counts_map[short])
        for k, v in counts_map.items():
            if k.lower() == short.lower():
                return int(v)
        return 0

    df_sla["NOT_SET"] = df_sla["_SLA_proj_normalized"].apply(lookup_count)

    # Drop helper column and write to new excel file (preserve existing sheet names if needed)
    df_sla = df_sla.drop(columns=["_SLA_proj_normalized"])

    # Write result to new workbook (single sheet)
    with pd.ExcelWriter(OUTPUT_SLA, engine="openpyxl") as writer:
        df_sla.to_excel(writer, sheet_name=SLA_SHEET, index=False)

    print(f"Done. Wrote updated SLA sheet to: {OUTPUT_SLA}")
    print("Summary of NOT_SET counts (sample up to 20):")
    sample = {k: v for i, (k, v) in enumerate(counts_map.items()) if i < 20}
    for k, v in sample.items():
        print(f"  {k!s}: {v}")

if __name__ == "__main__":
    main()